local grenades = {}
local MIDDLE_THROW_ADDITIONAL_LERP_OFFSET = 200

local function lerp3(t, v1, v2, v3) 
	local a = vmath.lerp(t,v1,v2)
	local b = vmath.lerp(t,v2,v3)
	local c = vmath.lerp(t, a, b)
	return c
end

local function dkill(self, handle, dt)
	go.delete()
end

function update(self, dt)
	local instance = grenades[go.get_id()]
	if instance and instance["active"] then
		go.set_rotation(vmath.quat_rotation_z(socket.gettime()*10%(math.pi*2)), "#sprite")
		local t = math.min(1, (socket.gettime()-instance["start"])/instance["duration"]) -- Min to prevent overshooting/extrapolating
		local pos = lerp3(t, instance["origin"], instance["point3"], instance["target"])
		go.set_position(pos)

		if t >= 1 then -- If ended
			instance["active"] = false
			msg.post(instance["sender"], "boom", {pos=pos, id=instance["id"]})
			timer.delay(1, false, dkill)
			-- TODO: boom
		end
	end
end

function on_message(self, message_id, message, sender)
	-- {"sprite":"normiz","controlled":false,"id":1,"name":"TestHorse"}
	-- print(json.encode({message_id, message, sender}))
	if message_id == hash("init") then
		message["start"] = socket.gettime()

		-- Generate middle point to implement parabalistic trajectory
		local middle = (message["origin"]+message["target"])/2
		local dir = vmath.normalize(message["target"]-message["origin"])
		local normal = vmath.cross(dir, vmath.vector3(0, 0, 1))
		local dirmem = math.abs(vmath.dot(normal, vmath.vector3(0, 1, 0)))

		message["point3"] = middle + vmath.vector3(0, MIDDLE_THROW_ADDITIONAL_LERP_OFFSET, 0) * dirmem
		message["active"] = true
		message["sender"] = sender
		grenades[go.get_id()] = message
	end
end
